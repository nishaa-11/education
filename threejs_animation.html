<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Video Renderer</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden;
            background: #000;
        }
        canvas { 
            display: block; 
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Configuration from query params
        const urlParams = new URLSearchParams(window.location.search);
        const animationType = urlParams.get('type') || 'photosynthesis';
        const duration = parseFloat(urlParams.get('duration') || '10');
        
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, 1920/1080, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(1920, 1080);
        renderer.setClearColor(0x87CEEB);
        document.body.appendChild(renderer.domElement);
        
        camera.position.z = 15;
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);
        
        // Animation objects
        let sun, plant, particles = [];
        const startTime = Date.now();
        
        // Create Sun
        function createSun() {
            const geometry = new THREE.SphereGeometry(2, 32, 32);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xFFD700,
                emissive: 0xFFD700,
                emissiveIntensity: 1
            });
            sun = new THREE.Mesh(geometry, material);
            sun.position.set(-8, 5, 0);
            scene.add(sun);
            
            // Sun rays
            const rayGeometry = new THREE.BoxGeometry(0.1, 3, 0.1);
            const rayMaterial = new THREE.MeshBasicMaterial({ color: 0xFFD700 });
            
            for (let i = 0; i < 12; i++) {
                const ray = new THREE.Mesh(rayGeometry, rayMaterial);
                const angle = (i / 12) * Math.PI * 2;
                ray.position.set(
                    sun.position.x + Math.cos(angle) * 2.5,
                    sun.position.y + Math.sin(angle) * 2.5,
                    0
                );
                ray.rotation.z = angle;
                scene.add(ray);
                sun.userData.rays = sun.userData.rays || [];
                sun.userData.rays.push(ray);
            }
        }
        
        // Create Plant
        function createPlant() {
            plant = new THREE.Group();
            
            // Stem
            const stemGeometry = new THREE.CylinderGeometry(0.2, 0.3, 8, 8);
            const stemMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.position.y = 0;
            plant.add(stem);
            
            // Leaves
            const leafGeometry = new THREE.SphereGeometry(1.2, 16, 16);
            leafGeometry.scale(1.5, 0.5, 0.3);
            const leafMaterial = new THREE.MeshLambertMaterial({ color: 0x32CD32 });
            
            const leaf1 = new THREE.Mesh(leafGeometry, leafMaterial);
            leaf1.position.set(-1.2, 2, 0);
            leaf1.rotation.z = Math.PI / 6;
            plant.add(leaf1);
            
            const leaf2 = new THREE.Mesh(leafGeometry, leafMaterial);
            leaf2.position.set(1.2, 1, 0);
            leaf2.rotation.z = -Math.PI / 6;
            plant.add(leaf2);
            
            // Flower
            const flowerGeometry = new THREE.SphereGeometry(0.6, 16, 16);
            const flowerMaterial = new THREE.MeshLambertMaterial({ color: 0xFF69B4 });
            const flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
            flower.position.y = 4.5;
            plant.add(flower);
            
            // Petals
            const petalGeometry = new THREE.SphereGeometry(0.4, 8, 8);
            petalGeometry.scale(1.2, 0.6, 0.3);
            const petalMaterial = new THREE.MeshLambertMaterial({ color: 0xFF1493 });
            
            for (let i = 0; i < 6; i++) {
                const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                const angle = (i / 6) * Math.PI * 2;
                petal.position.set(
                    Math.cos(angle) * 0.7,
                    4.5 + Math.sin(angle) * 0.7,
                    0
                );
                plant.add(petal);
            }
            
            plant.position.set(0, -8, 0);
            plant.scale.set(0, 0, 0); // Start from zero
            scene.add(plant);
        }
        
        // Create Particles
        function createParticles(color, count, label) {
            const particleGroup = new THREE.Group();
            const geometry = new THREE.SphereGeometry(0.3, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color: color });
            
            for (let i = 0; i < count; i++) {
                const particle = new THREE.Mesh(geometry, material);
                particle.userData.offset = i * 0.2;
                particle.userData.label = label;
                particleGroup.add(particle);
            }
            
            return particleGroup;
        }
        
        // Initialize based on type
        if (animationType === 'photosynthesis') {
            createSun();
            createPlant();
            
            // CO2 particles
            const co2Group = createParticles(0x808080, 8, 'CO2');
            co2Group.position.set(-10, 0, 0);
            scene.add(co2Group);
            particles.push({ group: co2Group, target: { x: 0, y: 0 }, speed: 0.05 });
            
            // O2 particles
            const o2Group = createParticles(0x90EE90, 8, 'O2');
            o2Group.position.set(0, 0, 0);
            scene.add(o2Group);
            particles.push({ group: o2Group, target: { x: 10, y: 5 }, speed: 0.03 });
        }
        
        // Animation loop
        let frameCount = 0;
        const targetFrames = Math.floor(duration * 30); // 30 fps
        
        function animate() {
            const elapsed = (Date.now() - startTime) / 1000;
            const progress = Math.min(elapsed / duration, 1);
            
            // Rotate sun rays
            if (sun && sun.userData.rays) {
                sun.userData.rays.forEach((ray, i) => {
                    const angle = (i / 12) * Math.PI * 2 + elapsed;
                    ray.position.set(
                        sun.position.x + Math.cos(angle) * 2.5,
                        sun.position.y + Math.sin(angle) * 2.5,
                        0
                    );
                    ray.rotation.z = angle;
                });
            }
            
            // Grow plant
            if (plant) {
                const growthProgress = Math.min(progress * 1.5, 1);
                const scale = growthProgress;
                plant.scale.set(scale, scale, scale);
                
                // Gentle sway
                plant.rotation.z = Math.sin(elapsed * 2) * 0.1;
            }
            
            // Move particles
            particles.forEach(({ group, target, speed }) => {
                group.children.forEach((particle, i) => {
                    const offset = particle.userData.offset;
                    const t = Math.min((elapsed + offset) * speed, 1);
                    
                    particle.position.x = THREE.MathUtils.lerp(
                        group.position.x,
                        target.x,
                        t
                    ) + Math.sin(elapsed * 3 + i) * 0.5;
                    
                    particle.position.y = THREE.MathUtils.lerp(
                        group.position.y,
                        target.y,
                        t
                    ) + Math.cos(elapsed * 2 + i) * 0.3;
                });
            });
            
            renderer.render(scene, camera);
            
            frameCount++;
            
            if (frameCount < targetFrames && progress < 1) {
                requestAnimationFrame(animate);
            } else {
                // Signal completion
                window.renderComplete = true;
            }
        }
        
        animate();
    </script>
</body>
</html>
